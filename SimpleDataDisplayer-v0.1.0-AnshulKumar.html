<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Chart Viewer (Offline)</title>
  <style>
    body { 
      font-family: sans-serif; 
      padding: 20px; 
      background: #f5f5f5;
    }
    
    h1 { color: #333; }
    
    #fileInput { 
      margin-bottom: 20px; 
      padding: 10px;
    }
    
    .controls {
      background: white;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #555;
    }
    
    select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 3px;
      font-size: 14px;
    }
    
    button {
      padding: 10px 20px;
      background: steelblue;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 5px;
    }
    
    button:hover {
      background: #1a5490;
    }
    
    .controls h2 {
      margin-top: 0;
      border-bottom: 2px solid steelblue;
      padding-bottom: 10px;
    }
    
    .controls h3 {
      margin-top: 20px;
      margin-bottom: 10px;
      color: #333;
    }
    
    table { 
      border-collapse: collapse; 
      margin-top: 20px; 
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    th, td { 
      border: 1px solid #ddd; 
      padding: 10px; 
      text-align: right; 
    }
    
    th { background: #f0f0f0; font-weight: bold; }
    
    td:first-child, th:first-child {
      text-align: left;
    }
    
    .contingency-table {
      margin-top: 10px;
      overflow-x: auto;
    }
    
    .chart-container { 
      margin: 30px 0; 
      background: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .chart-container h3 {
      margin-top: 0;
      color: #333;
    }
    
    svg { 
      border: 1px solid #eee; 
      background: #fafafa; 
    }
    
    .axis { stroke: #333; stroke-width: 2; }
    .tick { stroke: #ccc; stroke-width: 1; }
    .tick-label { font-size: 12px; fill: #666; }
    .axis-label { font-size: 13px; font-weight: bold; fill: #333; }
    .bar { fill: steelblue; }
    .bar:hover { fill: #1a5490; }
    .point { fill: crimson; opacity: 0.6; }
    .point:hover { opacity: 1; }
    .grid-line { stroke: #eee; stroke-width: 1; }
    
    .box-line { stroke: #333; stroke-width: 2; }
    .box-fill { fill: steelblue; opacity: 0.7; stroke: steelblue; stroke-width: 1;}
    .box-median { stroke: white; stroke-width: 2; }
    .box-whisker { stroke: #333; stroke-width: 1; }
    
    .data-table-title {
      margin-top: 30px;
      font-size: 18px;
      font-weight: bold;
      color: #333;
    }

    .contingency-note {
      font-size: 12px;
      color: #666;
      font-style: italic;
      margin-top: 5px;
    }

    .pm-note {
      margin-top: 4px;
      color: #666;
      font-size: 13px;
      font-style: italic;
    }
  </style>
</head>
<body>
  <h1>ðŸ“Š Offline CSV Chart, Table & Box Plot Viewer</h1>
  <div class="pm-note">Project Manager: Anshul Kumar</div>
  
  <input type="file" id="fileInput" accept=".csv,text/csv" />
  
  <div id="controls" style="display:none;">
    <div class="controls">
      <h2>Chart & Table Controls</h2>
      
      <h3>ðŸ“Š Histogram</h3>
      <div class="control-group">
        <label for="histCol">Variable:</label>
        <select id="histCol"></select>
        <button onclick="updateCharts()">Update</button>
      </div>
      
      <h3>ðŸ“ˆ Scatter Plot</h3>
      <div class="control-group">
        <label for="scatterXCol">X Variable:</label>
        <select id="scatterXCol"></select>
      </div>
      <div class="control-group">
        <label for="scatterYCol">Y Variable:</label>
        <select id="scatterYCol"></select>
        <button onclick="updateCharts()">Update</button>
      </div>
      <!-- NEW: optional toggle for trendline -->
      <div class="control-group">
        <label><input type="checkbox" id="showTrendline"> Show line of best fit</label>
      </div>
      
      <h3>ðŸŸ« Box Plot</h3>
      <div class="control-group">
        <label for="boxPlotValueCol">Value Variable (Numeric):</label>
        <select id="boxPlotValueCol"></select>
      </div>
      <div class="control-group">
        <label for="boxPlotGroupCol">Group Variable (Optional):</label>
        <select id="boxPlotGroupCol">
            <option value="" selected>--- None (Single Plot) ---</option>
        </select>
        <button onclick="updateCharts()">Update</button>
      </div>

      <h3>ðŸ“‹ 1-Way Contingency Table</h3>
      <div class="control-group">
        <label for="oneWayCol">Variable:</label>
        <select id="oneWayCol"></select>
        <button onclick="updateCharts()">Update</button>
      </div>

      <h3>ðŸ“‹ 2-Way Contingency Table</h3>
      <div class="control-group">
        <label for="twoWayCol1">Row Variable:</label>
        <select id="twoWayCol1"></select>
      </div>
      <div class="control-group">
        <label for="twoWayCol2">Column Variable:</label>
        <select id="twoWayCol2"></select>
        <button onclick="updateCharts()">Update</button>
      </div>
    </div>
  </div>
  
  <div id="output"></div>

  <script>
    let globalData = null;

    document.getElementById('fileInput').addEventListener('change', handleFile);

    function handleFile(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(event) {
        const csv = event.target.result;
        globalData = parseCSV(csv);
        initializeControls();
        updateCharts();
      };
      reader.readAsText(file);
    }

    // Simple CSV parser
    function parseCSV(csvText) {
      const lines = csvText.trim().split('\n');
      if (lines.length < 2) return { headers: [], rows: [] };
      const headers = lines[0].split(',').map(h => h.trim());
      const rows = lines.slice(1).map(line => {
        const values = line.split(',').map(v => v.trim());
        const row = {};
        headers.forEach((h, i) => {
          if (i < values.length) {
            const num = Number(values[i]);
            row[h] = isNaN(num) ? values[i] : num;
          }
        });
        return row;
      });
      return { headers, rows };
    }

    function getNumericColumns() {
      if (!globalData) return [];
      return globalData.headers.filter(h => 
        globalData.rows.every(r => typeof r[h] === 'number' && !isNaN(r[h]))
      );
    }

    function getCategoricalColumns() {
      if (!globalData) return [];
      return globalData.headers.filter(h => 
        globalData.rows.some(r => typeof r[h] === 'string' || (typeof r[h] === 'number' && isNaN(r[h])))
      );
    }

    function getAllColumns() {
      if (!globalData) return [];
      return globalData.headers;
    }

    function initializeControls() {
      const numericCols = getNumericColumns();
      const categoricalCols = getCategoricalColumns();
      const allCols = getAllColumns();
      const controlsDiv = document.getElementById('controls');
      
      controlsDiv.style.display = 'block';

      // Histogram dropdown (numeric only)
      populateSelect('histCol', numericCols);

      // Scatter plot dropdowns (numeric only)
      const scatterXCol = document.getElementById('scatterXCol');
      const scatterYCol = document.getElementById('scatterYCol');
      scatterXCol.innerHTML = '';
      scatterYCol.innerHTML = '';
      numericCols.forEach(col => {
        createOption(scatterXCol, col, col);
        createOption(scatterYCol, col, col);
      });
      if (numericCols.length >= 2) {
        scatterXCol.value = numericCols[0];
        scatterYCol.value = numericCols[1];
      }

      // Box Plot
      populateSelect('boxPlotValueCol', numericCols);
      const boxPlotGroupCol = document.getElementById('boxPlotGroupCol');
      boxPlotGroupCol.innerHTML = ''; 
      // âœ¨ Change: show ALL columns in the Group dropdown
      allCols.forEach(col => {
        createOption(boxPlotGroupCol, col, col);
      });
      createOption(boxPlotGroupCol, "", "--- None (Single Plot) ---", true);

      // 1-Way Table (All)
      populateSelect('oneWayCol', allCols);
      if (categoricalCols.length > 0) {
        document.getElementById('oneWayCol').value = categoricalCols[0];
      }

      // 2-Way Table (All)
      const twoWayCol1 = document.getElementById('twoWayCol1');
      const twoWayCol2 = document.getElementById('twoWayCol2');
      twoWayCol1.innerHTML = '';
      twoWayCol2.innerHTML = '';
      
      allCols.forEach(col => {
        createOption(twoWayCol1, col, col);
        createOption(twoWayCol2, col, col);
      });
      if (allCols.length >= 2) {
        twoWayCol1.value = allCols[0];
        twoWayCol2.value = allCols[1];
      }
    }
    
    function populateSelect(id, options) {
        const select = document.getElementById(id);
        select.innerHTML = '';
        options.forEach(opt => createOption(select, opt, opt));
    }

    function createOption(selectElement, value, text, isSelected = false) {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = text;
        if (isSelected) option.selected = true;
        selectElement.appendChild(option);
    }

    function updateCharts() {
      renderOutput();
    }

    function renderOutput() {
      if (!globalData) return;

      const container = document.getElementById('output');
      container.innerHTML = '';

      // Data table title
      const dataTableTitle = document.createElement('div');
      dataTableTitle.className = 'data-table-title';
      dataTableTitle.textContent = 'ðŸ“„ Data Table';
      container.appendChild(dataTableTitle);

      // Render data table
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      globalData.headers.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h;
        trHead.appendChild(th);
      });
      thead.appendChild(trHead);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      globalData.rows.forEach(row => {
        const tr = document.createElement('tr');
        globalData.headers.forEach(h => {
          const td = document.createElement('td');
          td.textContent = row[h];
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      container.appendChild(table);

      // --- Chart Rendering ---

      // Histogram
      const histCol = document.getElementById('histCol').value;
      if (histCol && getNumericColumns().includes(histCol)) {
        const values = globalData.rows.map(r => r[histCol]).filter(v => typeof v === 'number' && !isNaN(v));
        if (values.length > 0) {
            const histDiv = document.createElement('div');
            histDiv.className = 'chart-container';
            histDiv.innerHTML = `<h3>ðŸ“Š Histogram: ${histCol}</h3>`;
            histDiv.appendChild(createHistogramSVG(values, histCol, 500, 300));
            container.appendChild(histDiv);
        }
      }

      // Scatter Plot
      const scatterXCol = document.getElementById('scatterXCol').value;
      const scatterYCol = document.getElementById('scatterYCol').value;
      if (scatterXCol && scatterYCol && getNumericColumns().includes(scatterXCol) && getNumericColumns().includes(scatterYCol)) {
        const points = globalData.rows.map(r => ({ 
          x: r[scatterXCol], 
          y: r[scatterYCol] 
        })).filter(p => typeof p.x === 'number' && !isNaN(p.x) && typeof p.y === 'number' && !isNaN(p.y));
        
        if (points.length > 0) {
            const scatterDiv = document.createElement('div');
            scatterDiv.className = 'chart-container';
            scatterDiv.innerHTML = `<h3>ðŸ“ˆ Scatter Plot: ${scatterXCol} vs ${scatterYCol}</h3>`;
            scatterDiv.appendChild(
              createScatterPlotSVG(
                points,
                scatterXCol,
                scatterYCol,
                500,
                300,
                document.getElementById('showTrendline').checked
              )
            );
            container.appendChild(scatterDiv);
        }
      }
      
      // Box Plots
      const boxPlotValueCol = document.getElementById('boxPlotValueCol').value;
      const boxPlotGroupCol = document.getElementById('boxPlotGroupCol').value;

      if (boxPlotValueCol && getNumericColumns().includes(boxPlotValueCol)) {
          const allValues = globalData.rows.map(r => r[boxPlotValueCol]).filter(v => typeof v === 'number' && !isNaN(v));

          if (!boxPlotGroupCol) {
              // Single Box Plot
              if (allValues.length > 0) {
                  const boxDiv = document.createElement('div');
                  boxDiv.className = 'chart-container';
                  boxDiv.innerHTML = `<h3>ðŸŸ« Box Plot: ${boxPlotValueCol} (Overall)</h3>`;
                  boxDiv.appendChild(createBoxPlotSVG([allValues], [boxPlotValueCol], 500, 300));
                  container.appendChild(boxDiv);
              }
          } else {
              // Grouped Box Plot
              const groups = [...new Set(globalData.rows.map(r => r[boxPlotGroupCol]))].sort((a, b) => {
                const numA = Number(a);
                const numB = Number(b);
                if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                return String(a).localeCompare(String(b));
              });

              const groupedDataMap = {};
              groups.forEach(group => {
                  groupedDataMap[group] = globalData.rows
                      .filter(r => r[boxPlotGroupCol] === group)
                      .map(r => r[boxPlotValueCol])
                      .filter(v => typeof v === 'number' && !isNaN(v));
              });

              const dataSets = groups.map(g => groupedDataMap[g]).filter(d => d.length > 0);
              
              if (dataSets.length > 0) {
                  const boxDiv = document.createElement('div');
                  boxDiv.className = 'chart-container';
                  boxDiv.innerHTML = `<h3>ðŸŸ« Box Plot: ${boxPlotValueCol} by ${boxPlotGroupCol}</h3>`;
                  boxDiv.appendChild(createBoxPlotSVG(dataSets, groups, 500, 300));
                  container.appendChild(boxDiv);
              }
          }
      }

      // 1-way contingency table
      const oneWayCol = document.getElementById('oneWayCol').value;
      if (oneWayCol) {
        const oneWayDiv = document.createElement('div');
        oneWayDiv.className = 'chart-container';
        oneWayDiv.innerHTML = `<h3>ðŸ“‹ 1-Way Contingency Table: ${oneWayCol}</h3>`;
        const oneWayTable = createOneWayTable(oneWayCol);
        oneWayDiv.appendChild(oneWayTable);
        oneWayDiv.insertAdjacentHTML('beforeend', '<div class="contingency-note">Shows frequency of each category</div>');
        container.appendChild(oneWayDiv);
      }

      // 2-way contingency table
      const twoWayCol1 = document.getElementById('twoWayCol1').value;
      const twoWayCol2 = document.getElementById('twoWayCol2').value;
      if (twoWayCol1 && twoWayCol2 && twoWayCol1 !== twoWayCol2) {
        const twoWayDiv = document.createElement('div');
        twoWayDiv.className = 'chart-container';
        twoWayDiv.innerHTML = `<h3>ðŸ“‹ 2-Way Contingency Table: ${twoWayCol1} Ã— ${twoWayCol2}</h3>`;
        const twoWayTable = createTwoWayTable(twoWayCol1, twoWayCol2);
        twoWayDiv.appendChild(twoWayTable);
        twoWayDiv.insertAdjacentHTML('beforeend', '<div class="contingency-note">Rows: ' + twoWayCol1 + ' | Columns: ' + twoWayCol2 + '</div>');
        container.appendChild(twoWayDiv);
      }
    }

    // --- Box Plot Utility Functions (FIXED) ---

    function getQuartiles(arr) {
      const s = arr.filter(v => Number.isFinite(v)).slice().sort((a,b)=>a-b);
      const n = s.length;
      if (n === 0) {
        return { q1: 0, median: 0, q3: 0, iqr: 0, lowerWhisker: 0, upperWhisker: 0 };
      }
      // linear interpolation quantiles
      const qAt = (p) => {
        if (n === 1) return s[0];
        const pos = (n - 1) * p;
        const base = Math.floor(pos);
        const rest = pos - base;
        return rest ? s[base] + rest * (s[base + 1] - s[base]) : s[base];
      };

      const q1 = qAt(0.25);
      const median = qAt(0.50);
      const q3 = qAt(0.75);
      const iqr = q3 - q1;

      // fences
      const lowerFence = q1 - 1.5 * iqr;
      const upperFence = q3 + 1.5 * iqr;

      // whiskers: most extreme inliers within fences
      let lowerWhisker = s[0];
      for (let i = 0; i < n; i++) {
        if (s[i] >= lowerFence) { lowerWhisker = s[i]; break; }
      }
      let upperWhisker = s[n - 1];
      for (let i = n - 1; i >= 0; i--) {
        if (s[i] <= upperFence) { upperWhisker = s[i]; break; }
      }

      return { q1, median, q3, iqr, lowerWhisker, upperWhisker };
    }

    function createBoxPlotSVG(dataSets, labels, width = 500, height = 300) {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);

        const padding = { top: 30, right: 30, bottom: 60, left: 60 };
        const chartW = width - padding.left - padding.right;
        const chartH = height - padding.top - padding.bottom;

        const numBoxes = dataSets.length;
        const boxWidth = (chartW / numBoxes) * 0.6; 

        const stats = dataSets.map(set => getQuartiles(set));
        
        const allValues = dataSets.flat();
        if (allValues.length === 0) return svg;

        const minValue = Math.min(...allValues);
        const maxValue = Math.max(...allValues);
        const valueRange = maxValue - minValue || 1;

        const yScale = val => padding.top + chartH - ((val - minValue) / valueRange) * chartH;

        for (let i = 0; i <= 5; i++) {
            const y = padding.top + (i / 5) * chartH;
            const line = document.createElementNS(svg.namespaceURI, 'line');
            line.setAttribute('class', 'grid-line');
            line.setAttribute('x1', padding.left);
            line.setAttribute('x2', width - padding.right);
            line.setAttribute('y1', y);
            line.setAttribute('y2', y);
            svg.appendChild(line);
        }
        
        const xAxis = document.createElementNS(svg.namespaceURI, 'line');
        xAxis.setAttribute('class', 'axis');
        xAxis.setAttribute('x1', padding.left);
        xAxis.setAttribute('y1', height - padding.bottom);
        xAxis.setAttribute('x2', width - padding.right);
        xAxis.setAttribute('y2', height - padding.bottom);
        svg.appendChild(xAxis);

        const yAxis = document.createElementNS(svg.namespaceURI, 'line');
        yAxis.setAttribute('class', 'axis');
        yAxis.setAttribute('x1', padding.left);
        yAxis.setAttribute('y1', padding.top);
        yAxis.setAttribute('x2', padding.left);
        yAxis.setAttribute('y2', height - padding.bottom);
        svg.appendChild(yAxis);
        
        for (let i = 0; i <= 5; i++) {
            const val = minValue + (i / 5) * valueRange;
            const y = yScale(val);
            const text = document.createElementNS(svg.namespaceURI, 'text');
            text.setAttribute('class', 'tick-label');
            text.setAttribute('x', padding.left - 10);
            text.setAttribute('y', y + 5);
            text.setAttribute('text-anchor', 'end');
            text.textContent = val.toFixed(1);
            svg.appendChild(text);
        }

        stats.forEach((stat, i) => {
            const centerX = padding.left + (i + 0.5) * (chartW / numBoxes);
            const boxTop = yScale(stat.q3);
            const boxHeight = yScale(stat.q1) - yScale(stat.q3);

            const rect = document.createElementNS(svg.namespaceURI, 'rect');
            rect.setAttribute('class', 'box-fill');
            rect.setAttribute('x', centerX - boxWidth / 2);
            rect.setAttribute('y', boxTop);
            rect.setAttribute('width', boxWidth);
            rect.setAttribute('height', Math.max(1, boxHeight));
            svg.appendChild(rect);

            const medianY = yScale(stat.median);
            const medianLine = document.createElementNS(svg.namespaceURI, 'line');
            medianLine.setAttribute('class', 'box-median');
            medianLine.setAttribute('x1', centerX - boxWidth / 2);
            medianLine.setAttribute('y1', medianY);
            medianLine.setAttribute('x2', centerX + boxWidth / 2);
            medianLine.setAttribute('y2', medianY);
            svg.appendChild(medianLine);

            const whiskerYMin = yScale(stat.lowerWhisker);
            const whiskerYMax = yScale(stat.upperWhisker);

            const whiskerLine = document.createElementNS(svg.namespaceURI, 'line');
            whiskerLine.setAttribute('class', 'box-whisker');
            whiskerLine.setAttribute('x1', centerX);
            whiskerLine.setAttribute('y1', whiskerYMin);
            whiskerLine.setAttribute('x2', centerX);
            whiskerLine.setAttribute('y2', whiskerYMax);
            svg.appendChild(whiskerLine);
            
            const capTop = document.createElementNS(svg.namespaceURI, 'line');
            capTop.setAttribute('class', 'box-whisker');
            capTop.setAttribute('x1', centerX - boxWidth / 4);
            capTop.setAttribute('y1', whiskerYMax);
            capTop.setAttribute('x2', centerX + boxWidth / 4);
            capTop.setAttribute('y2', whiskerYMax);
            svg.appendChild(capTop);

            const capBottom = document.createElementNS(svg.namespaceURI, 'line');
            capBottom.setAttribute('class', 'box-whisker');
            capBottom.setAttribute('x1', centerX - boxWidth / 4);
            capBottom.setAttribute('y1', whiskerYMin);
            capBottom.setAttribute('x2', centerX + boxWidth / 4);
            capBottom.setAttribute('y2', whiskerYMin);
            svg.appendChild(capBottom);

            const set = dataSets[i];
            for (const v of set) {
              if (v < stat.lowerWhisker || v > stat.upperWhisker) {
                const circle = document.createElementNS(svg.namespaceURI, 'circle');
                circle.setAttribute('class', 'point');
                circle.setAttribute('cx', centerX);
                circle.setAttribute('cy', yScale(v));
                circle.setAttribute('r', 3);
                svg.appendChild(circle);
              }
            }
        });

        labels.forEach((label, i) => {
            const centerX = padding.left + (i + 0.5) * (chartW / numBoxes);
            const text = document.createElementNS(svg.namespaceURI, 'text');
            text.setAttribute('class', 'tick-label');
            text.setAttribute('x', centerX);
            text.setAttribute('y', height - 15);
            text.setAttribute('text-anchor', 'middle');
            text.textContent = label;
            svg.appendChild(text);
        });
        
        const xLabel = document.createElementNS(svg.namespaceURI, 'text');
        xLabel.setAttribute('class', 'axis-label');
        xLabel.setAttribute('x', width / 2);
        xLabel.setAttribute('y', height - 5);
        xLabel.setAttribute('text-anchor', 'middle');
        xLabel.textContent = labels.length === 1 ? labels[0] : `Groups`;
        svg.appendChild(xLabel);

        const yLabel = document.createElementNS(svg.namespaceURI, 'text');
        yLabel.setAttribute('class', 'axis-label');
        yLabel.setAttribute('x', -height / 2);
        yLabel.setAttribute('y', 15);
        yLabel.setAttribute('text-anchor', 'middle');
        yLabel.setAttribute('transform', 'rotate(-90 15 ' + (height / 2) + ')');
        yLabel.textContent = 'Value';
        svg.appendChild(yLabel);

        return svg;
    }


    // --- Table Logic (Same as before) ---

    function createOneWayTable(colName) {
      const table = document.createElement('table');
      const containerDiv = document.createElement('div');
      containerDiv.className = 'contingency-table';

      const counts = {};
      globalData.rows.forEach(row => {
        const val = row[colName];
        counts[val] = (counts[val] || 0) + 1;
      });

      const sortedKeys = Object.keys(counts).sort((a, b) => {
        const numA = Number(a);
        const numB = Number(b);
        if (!isNaN(numA) && !isNaN(numB)) {
          return numA - numB;
        }
        return String(a).localeCompare(String(b));
      });

      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      const thLabel = document.createElement('th');
      thLabel.textContent = colName;
      const thCount = document.createElement('th');
      thCount.textContent = 'Count';
      trHead.appendChild(thLabel);
      trHead.appendChild(thCount);
      thead.appendChild(trHead);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      let totalCount = 0;
      sortedKeys.forEach(key => {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td');
        td1.textContent = key;
        td1.style.textAlign = 'left';
        const td2 = document.createElement('td');
        td2.textContent = counts[key];
        tr.appendChild(td1);
        tr.appendChild(td2);
        tbody.appendChild(tr);
        totalCount += counts[key];
      });

      const trTotal = document.createElement('tr');
      trTotal.style.fontWeight = 'bold';
      trTotal.style.borderTop = '2px solid #333';
      const tdTotalLabel = document.createElement('td');
      tdTotalLabel.textContent = 'Total';
      const tdTotalCount = document.createElement('td');
      tdTotalCount.textContent = totalCount;
      trTotal.appendChild(tdTotalLabel);
      trTotal.appendChild(tdTotalCount);
      tbody.appendChild(trTotal);

      table.appendChild(tbody);
      containerDiv.appendChild(table);
      return containerDiv;
    }

    function createTwoWayTable(col1, col2) {
      const table = document.createElement('table');
      const containerDiv = document.createElement('div');
      containerDiv.className = 'contingency-table';

      const vals1 = [...new Set(globalData.rows.map(r => r[col1]))].sort((a, b) => {
        const numA = Number(a);
        const numB = Number(b);
        if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
        return String(a).localeCompare(String(b));
      });

      const vals2 = [...new Set(globalData.rows.map(r => r[col2]))].sort((a, b) => {
        const numA = Number(a);
        const numB = Number(b);
        if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
        return String(a).localeCompare(String(b));
      });

      const matrix = {};
      vals1.forEach(v1 => {
        matrix[v1] = {};
        vals2.forEach(v2 => {
          matrix[v1][v2] = 0;
        });
      });

      globalData.rows.forEach(row => {
        const v1 = row[col1];
        const v2 = row[col2];
        if (matrix[v1] !== undefined && matrix[v1][v2] !== undefined) {
            matrix[v1][v2]++;
        }
      });

      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      const thEmpty = document.createElement('th');
      thEmpty.textContent = col1 + ' \\ ' + col2;
      trHead.appendChild(thEmpty);

      vals2.forEach(v2 => {
        const th = document.createElement('th');
        th.textContent = v2;
        trHead.appendChild(th);
      });

      const thTotal = document.createElement('th');
      thTotal.textContent = 'Total';
      trHead.appendChild(thTotal);
      thead.appendChild(trHead);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const colTotals = {};
      vals2.forEach(v2 => colTotals[v2] = 0);

      vals1.forEach(v1 => {
        const tr = document.createElement('tr');
        const tdLabel = document.createElement('td');
        tdLabel.textContent = v1;
        tdLabel.style.textAlign = 'left';
        tdLabel.style.fontWeight = 'bold';
        tr.appendChild(tdLabel);

        let rowTotal = 0;
        vals2.forEach(v2 => {
          const td = document.createElement('td');
          const count = matrix[v1][v2];
          td.textContent = count;
          tr.appendChild(td);
          colTotals[v2] += count;
          rowTotal += count;
        });

        const tdRowTotal = document.createElement('td');
        tdRowTotal.textContent = rowTotal;
        tdRowTotal.style.fontWeight = 'bold';
        tr.appendChild(tdRowTotal);
        tbody.appendChild(tr);
      });

      const trTotal = document.createElement('tr');
      trTotal.style.fontWeight = 'bold';
      trTotal.style.borderTop = '2px solid #333';
      const tdTotalLabel = document.createElement('td');
      tdTotalLabel.textContent = 'Total';
      tdTotalLabel.style.textAlign = 'left';
      trTotal.appendChild(tdTotalLabel);

      let grandTotal = 0;
      vals2.forEach(v2 => {
        const td = document.createElement('td');
        const total = colTotals[v2];
        td.textContent = total;
        trTotal.appendChild(td);
        grandTotal += total;
      });

      const tdGrandTotal = document.createElement('td');
      tdGrandTotal.textContent = grandTotal;
      trTotal.appendChild(tdGrandTotal);
      tbody.appendChild(trTotal);

      table.appendChild(tbody);
      containerDiv.appendChild(table);
      return containerDiv;
    }

    // --- Histogram SVG Logic ---
    function createHistogramSVG(values, colName, width = 500, height = 300) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      const padding = { top: 30, right: 20, bottom: 60, left: 60 };
      const chartW = width - padding.left - padding.right;
      const chartH = height - padding.top - padding.bottom;

      const min = Math.min(...values);
      const max = Math.max(...values);
      const range = max - min || 1;
      const bins = Math.min(10, Math.ceil(Math.sqrt(values.length)));
      const binWidth = range / bins;
      const counts = new Array(bins).fill(0);

      values.forEach(v => {
        let idx = Math.floor((v - min) / binWidth);
        if (idx >= bins) idx = bins - 1;
        counts[idx]++;
      });

      const maxCount = Math.max(...counts);

      const xScale = i => padding.left + (i / bins) * chartW;
      const yScale = c => padding.top + chartH - (c / maxCount) * chartH;

      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (i / 5) * chartH;
        const line = document.createElementNS(svg.namespaceURI, 'line');
        line.setAttribute('class', 'grid-line');
        line.setAttribute('x1', padding.left);
        line.setAttribute('x2', width - padding.right);
        line.setAttribute('y1', y);
        line.setAttribute('y2', y);
        svg.appendChild(line);
      }

      counts.forEach((count, i) => {
        const barX = xScale(i);
        const barW = xScale(i + 1) - barX - 2;
        const barY = yScale(count);
        const barH = padding.top + chartH - barY;

        const rect = document.createElementNS(svg.namespaceURI, 'rect');
        rect.setAttribute('class', 'bar');
        rect.setAttribute('x', barX);
        rect.setAttribute('y', barY);
        rect.setAttribute('width', Math.max(0, barW));
        rect.setAttribute('height', barH);
        svg.appendChild(rect);

        const binStart = (min + i * binWidth).toFixed(2);
        const text = document.createElementNS(svg.namespaceURI, 'text');
        text.setAttribute('class', 'tick-label');
        text.setAttribute('x', xScale(i + 0.5));
        text.setAttribute('y', height - 15);
        text.setAttribute('text-anchor', 'middle');
        text.textContent = binStart;
        svg.appendChild(text);
      });

      const xAxis = document.createElementNS(svg.namespaceURI, 'line');
      xAxis.setAttribute('class', 'axis');
      xAxis.setAttribute('x1', padding.left);
      xAxis.setAttribute('y1', height - padding.bottom);
      xAxis.setAttribute('x2', width - padding.right);
      xAxis.setAttribute('y2', height - padding.bottom);
      svg.appendChild(xAxis);

      const yAxis = document.createElementNS(svg.namespaceURI, 'line');
      yAxis.setAttribute('class', 'axis');
      yAxis.setAttribute('x1', padding.left);
      yAxis.setAttribute('y1', padding.top);
      yAxis.setAttribute('x2', padding.left);
      yAxis.setAttribute('y2', height - padding.bottom);
      svg.appendChild(yAxis);

      for (let i = 0; i <= 5; i++) {
        const count = Math.round((i / 5) * maxCount);
        const y = padding.top + chartH - (i / 5) * chartH;
        const text = document.createElementNS(svg.namespaceURI, 'text');
        text.setAttribute('class', 'tick-label');
        text.setAttribute('x', padding.left - 10);
        text.setAttribute('y', y + 5);
        text.setAttribute('text-anchor', 'end');
        text.textContent = count;
        svg.appendChild(text);
      }

      const xLabel = document.createElementNS(svg.namespaceURI, 'text');
      xLabel.setAttribute('class', 'axis-label');
      xLabel.setAttribute('x', width / 2);
      xLabel.setAttribute('y', height - 5);
      xLabel.setAttribute('text-anchor', 'middle');
      xLabel.textContent = colName;
      svg.appendChild(xLabel);

      const yLabel = document.createElementNS(svg.namespaceURI, 'text');
      yLabel.setAttribute('class', 'axis-label');
      yLabel.setAttribute('x', -height / 2);
      yLabel.setAttribute('y', 15);
      yLabel.setAttribute('transform', 'rotate(-90 15 ' + (height / 2) + ')');
      yLabel.textContent = 'Frequency';
      svg.appendChild(yLabel);

      return svg;
    }

    // --- Scatter Plot SVG Logic ---
    function createScatterPlotSVG(points, xColName, yColName, width = 500, height = 300, showTrendline = false) {
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      const padding = { top: 30, right: 20, bottom: 60, left: 60 };
      const chartW = width - padding.left - padding.right;
      const chartH = height - padding.top - padding.bottom;

      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const rangeX = maxX - minX || 1;
      const rangeY = maxY - minY || 1;

      const xScale = x => padding.left + ((x - minX) / rangeX) * chartW;
      const yScale = y => padding.top + chartH - ((y - minY) / rangeY) * chartH;

      for (let i = 0; i <= 5; i++) {
        const x = padding.left + (i / 5) * chartW;
        const line1 = document.createElementNS(svg.namespaceURI, 'line');
        line1.setAttribute('class', 'grid-line');
        line1.setAttribute('x1', x);
        line1.setAttribute('x2', x);
        line1.setAttribute('y1', padding.top);
        line1.setAttribute('y2', height - padding.bottom);
        svg.appendChild(line1);

        const y = padding.top + (i / 5) * chartH;
        const line2 = document.createElementNS(svg.namespaceURI, 'line');
        line2.setAttribute('class', 'grid-line');
        line2.setAttribute('x1', padding.left);
        line2.setAttribute('x2', width - padding.right);
        line2.setAttribute('y1', y);
        line2.setAttribute('y2', y);
        svg.appendChild(line2);
      }

      points.forEach(p => {
        const circle = document.createElementNS(svg.namespaceURI, 'circle');
        circle.setAttribute('class', 'point');
        circle.setAttribute('cx', xScale(p.x));
        circle.setAttribute('cy', yScale(p.y));
        circle.setAttribute('r', 4);
        svg.appendChild(circle);
      });

      const xAxis = document.createElementNS(svg.namespaceURI, 'line');
      xAxis.setAttribute('class', 'axis');
      xAxis.setAttribute('x1', padding.left);
      xAxis.setAttribute('y1', height - padding.bottom);
      xAxis.setAttribute('x2', width - padding.right);
      xAxis.setAttribute('y2', height - padding.bottom);
      svg.appendChild(xAxis);

      const yAxis = document.createElementNS(svg.namespaceURI, 'line');
      yAxis.setAttribute('class', 'axis');
      yAxis.setAttribute('x1', padding.left);
      yAxis.setAttribute('y1', padding.top);
      yAxis.setAttribute('x2', padding.left);
      yAxis.setAttribute('y2', height - padding.bottom);
      svg.appendChild(yAxis);

      for (let i = 0; i <= 5; i++) {
        const val = minX + (i / 5) * rangeX;
        const x = xScale(val);
        const text = document.createElementNS(svg.namespaceURI, 'text');
        text.setAttribute('class', 'tick-label');
        text.setAttribute('x', x);
        text.setAttribute('y', height - 15);
        text.setAttribute('text-anchor', 'middle');
        text.textContent = val.toFixed(1);
        svg.appendChild(text);
      }

      for (let i = 0; i <= 5; i++) {
        const val = minY + (i / 5) * rangeY;
        const y = yScale(val);
        const text = document.createElementNS(svg.namespaceURI, 'text');
        text.setAttribute('class', 'tick-label');
        text.setAttribute('x', padding.left - 10);
        text.setAttribute('y', y + 5);
        text.setAttribute('text-anchor', 'end');
        text.textContent = val.toFixed(1);
        svg.appendChild(text);
      }

      // Optional trendline (least squares)
      if (showTrendline && points.length >= 2) {
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        for (const p of points) {
          sumX += p.x; sumY += p.y; sumXY += p.x * p.y; sumX2 += p.x * p.x;
        }
        const n = points.length;
        const denom = (n * sumX2 - sumX * sumX);
        if (denom !== 0) {
          const m = (n * sumXY - sumX * sumY) / denom;
          const b = (sumY - m * sumX) / n;
          const x0 = minX, x1 = maxX;
          const y0 = m * x0 + b, y1 = m * x1 + b;

          const line = document.createElementNS(svg.namespaceURI, 'line');
          line.setAttribute('x1', xScale(x0));
          line.setAttribute('y1', yScale(y0));
          line.setAttribute('x2', xScale(x1));
          line.setAttribute('y2', yScale(y1));
          line.setAttribute('stroke', 'black');
          line.setAttribute('stroke-width', '2');
          line.setAttribute('stroke-dasharray', '6,4');
          svg.appendChild(line);
        }
      }

      const xLabel = document.createElementNS(svg.namespaceURI, 'text');
      xLabel.setAttribute('class', 'axis-label');
      xLabel.setAttribute('x', width / 2);
      xLabel.setAttribute('y', height - 5);
      xLabel.setAttribute('text-anchor', 'middle');
      xLabel.textContent = xColName;
      svg.appendChild(xLabel);

      const yLabel = document.createElementNS(svg.namespaceURI, 'text');
      yLabel.setAttribute('class', 'axis-label');
      yLabel.setAttribute('x', -height / 2);
      yLabel.setAttribute('y', 15);
      yLabel.setAttribute('transform', 'rotate(-90 15 ' + (height / 2) + ')');
      yLabel.textContent = yColName;
      svg.appendChild(yLabel);

      return svg;
    }
  </script>
</body>
</html>